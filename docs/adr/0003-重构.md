下面是把我们上面所有讨论**系统化整理**后的《**可编辑代码工作流平台 — 架构蓝图（合集 v1）**》。先给**结论快照**，然后按层次展开，最后给一条**关键决策问题**，便于你马上推进。

---

## 结论快照（一页纸）

* **架构范式**：领域驱动 + 六边形（Ports/Adapters）+ 轻量 CQRS + 事件驱动思维。
* **运行隔离**：**Web Worker + Comlink**（你已选 A：快速实现），主线程**硬超时**、Worker 可终止。
* **契约优先**：Graph IR（`ir/1.0`）、JSON Schema（Ajv）做 I/O 校验与示例驱动测试。
* **受控扩展**：**ESM 动态导入 / Module Federation（二选一）** + **Worker 沙箱** + **插件 Manifest/权限白名单**。
* **可观测性**：runId（ULID）/chainId 贯穿，结构化日志（NDJSON 导出）、Run Center 热力/曲线。
* **数据层**：IndexedDB（Dexie）本地化；后续可平滑接入后端存储。
* **工程化**：Monorepo + Public API（每包只暴露 `index.ts`）、依赖边界用 ESLint/DepCruiser 守护。
* **里程碑**：P0 打通“想法→蓝图→节点→运行/修复/嵌入”闭环；P1 Run Center & 版本固定；P2 服务化与安全加固。

---

## 1. 愿景与范围

**愿景**：从用户的**想法/需求**出发，AI 生成**蓝图**→拆为**DAG**，每个节点是最小可执行单元（MEU），可**运行/调试/修复**；平台支持**日志、版本、多节点串行测试**；并可通过 **Web Components/微前端/iframe** 嵌入外部系统；最终可将链路封装为对外服务接口。

**V1 包含**：

* 想法→蓝图→流程（DAG）
* AI 生成节点 handler + 示例 I/O
* 节点调试运行、静态校验、沙箱执行、日志捕捉、版本管理
* AI 修复（最小差异补丁，预览/应用/回滚）
* 子图串行测试（chainId 贯穿）
* 运行中心（Run Center）
* 组件化输出 `<workflow-node>` / `<workflow-flow>`

**V1 非目标**：多人协作、服务端沙箱、复杂权限、大规模调度。

---

## 2. 用户故事（摘要）

1. 用户输入业务想法，AI 生成结构化蓝图；
2. 一键转流程，AI 拆分为 DAG + 代码初稿；
3. 画布编辑节点，进入 NodePage 调试；
4. 报错时 AI 给补丁（Diff→应用→回滚）；
5. 选子图串行运行，查看链路 I/O 与日志；
6. 稳定链路可发布为服务并嵌入外部系统。

---

## 3. 分层与模块边界

**稳定边界（自上而下单向依赖）**

* **UI / Apps**（Studio、Embeds Demo）(docs/工作流编排_studio（模拟页面）.jsx)
* **App Services（CQRS 门面）**：Commands/Queries，聚合用例
* **Domain（领域内核）**：Node/Flow/Run/Version/Log 模型与规则
* **Ports（接口）**：StoragePort、RuntimePort、AIPlannerPort、LogPort…
* **Adapters（实现）**：Dexie 存储、Runner 客户端、AI 调用等

> **导入规则**：UI → App Services → Domain/Ports → Adapters。**禁止反向依赖**。

---

## 4. 领域模型与契约

* **核心实体**：Node（MEU）、Flow（DAG）、Run、Chain、Version、Log。
* **Graph IR**：统一导入/导出中间表示（`ir/1.0`，含 policies，如 network deny-by-default）。
* **I/O 校验**：Ajv + JSON Schema；`sampleInput/expectedOutput` = 最小可执行用例。

---

## 5. 运行时与执行协议（已选：Web Worker）

* **沙箱**：Web Worker（默认断网），通过 **Comlink** 事件流通讯；主线程**硬超时**（到时 `terminate()` 并上报 ERROR）。
* **协议**：

  * `ExecRequest`：`runId/nodeId/flowId/code/language/input/controls/env`
  * `ExecEvent`：`STARTED | LOG(level, fields) | RESULT(output, durationMs) | ERROR(name,message,stack)`
* **Node 代码约定**：`export async function handler(input, ctx) { ctx.log(level, data); return output; }`

---

## 6. AI 协调器（蓝图/生成/修复）

* **流水线**：需求→蓝图→DAG→代码初稿→运行→失败→**最小上下文**（错误栈、日志片段、I/O 切片）→**AST 级补丁**→回滚。
* **隐私/最小化上传**：仅上传相关函数体/错误片段，输入脱敏。
* **可重复性**：补丁与版本/运行快照绑定，支持“固定版本运行”。

---

## 7. 可观测性与 Run Center

* **统一上下文**：`chainId ~ traceId`，`runId ~ spanId`。
* **结构化日志**：`{ts, level, nodeId, runId, chainId, fields}`；NDJSON 导出。
* **视图**：运行列表/详情、错误热力、耗时曲线（P50/P95）、重试与超时统计。

---

## 8. 嵌入层（Web Components 优先）

* `<workflow-node>`：属性 `node-id`/`readonly`/`theme`；事件 `run/result/error/log/applyPatch/openNode`。
* `<workflow-flow>`：只读画布、可执行子图。
* **安全**：origin 白名单、启动握手（版本号）、后续加消息签名（HMAC/JWT）、默认跨域不回传明文 I/O（需授权二次取数）。

---

## 9. 数据与存储

* **前端**：IndexedDB（Dexie）承载 flows/nodes/versions/runs/logs；localStorage 仅放偏好。
* **日志分片**与清理阈值；NDJSON 导出。
* **后端预留**：将来切至 Postgres/ClickHouse 等与 IR/事件对齐，平滑迁移。

---

## 10. 前端工程与状态

* **Monorepo**：pnpm + Turborepo + Changesets。
* **状态管理**：Zustand（全局）+ XState/FSM（节点/运行生命周期）。
* **画布**：React Flow；编辑器：CodeMirror 6；打包：Vite。
* **AI 工具友好**（Claude Code/Codex）：

  * 每包仅暴露 **Public API（`index.ts`）**；
  * 小文件小函数；跨边界函数显式类型；统一错误模型 `{name,message,stack}`；
  * 在入口函数添加 3–5 行 Prompt 注释（输入/输出/副作用）。

---

## 11. 插件化与受控包加载（重点）

### 11.1 插件形态与生命周期

* **形态**：ESM 模块 / 远端 MF 远程包 / 用户上传代码片段。
* **生命周期**：`发现 → 校验(manifest+签名) → 装载 → 初始化 → 执行 → 卸载/更新`。
* **Manifest（建议 v0.1）**：

  ```json
  {
    "name": "plugin-foo",
    "version": "0.1.0",
    "apiVersion": "1.0",
    "capabilities": ["fs.read", "net.fetch"],   // V1 建议为空或极简
    "permissions": { "network": false },        // deny-by-default
    "entry": "./index.js",
    "exports": ["nodeFactory", "validator"]
  }
  ```

### 11.2 受控加载策略（两条路线，选其一做基线）

* **A）ESM 动态导入 + Worker 沙箱（轻量、实现快）**

  * 通过 `import()` + Blob/URL 动态装载插件；
  * 所有执行在 Worker 内，**默认断网**，仅开放白名单能力（通过 `ctx.capabilities`）。
  * 适合单体应用内的“用户上传/本地注册”型插件。
* **B）Module Federation + Worker 沙箱（跨应用、可共享）**

  * 平台作为 Host，插件作为 Remote（`remoteEntry.js`）；
  * 适合多仓/微前端、跨团队插件生态；
  * 成本略高，需版本协调与共享依赖治理。

> **共同安全基线**：
>
> * **Deny-by-default** 能力模型；
> * 插件 API 版本契约（`apiVersion`）+ 适配器；
> * 装载前校验：Manifest 校验、来源白名单、可选签名校验；
> * **Worker 侧审计**：拦截 `console`、结构化日志回传、运行时限流/超时。

### 11.3 插件 API（示意）

```ts
export interface WorkflowPlugin {
  meta: { name: string; version: string; apiVersion: string };
  register(reg: Registry): void; // 向平台注册 Node 类型/工具栏/校验器等
}

export interface Registry {
  addNodeType(kind: string, factory: NodeFactory): void;
  addValidator(fn: (node: Node) => Diagnostic[]): void;
}
```

---

## 12. 质量与测试

* **契约测试**：Schema 驱动 I/O 验证；
* **节点单测**：示例 I/O 快照测试；
* **串行实验**：拓扑排序 + 失败短路；
* **E2E**：Playwright（画布与嵌入交互）。
* **回归保护**：版本回滚前自动复跑关键用例；
* **性能预算**：画布渲染<16ms/帧、日志写入速率阈值与告警。

---

## 13. 非功能（NFR）

安全（默认断网、最小权限、来源验证、签名、脱敏上传）
可维护（核心无框架耦合、端口适配）
可扩展（未来扩 Node 类型：HttpNode/LLMNode…）
可观测（全链路 ID、结构化日志）
可移植（IR/Schema 稳定、Embedding 无宿主耦合）
离线优先（本地能完整闭环）

---

## 14. 里程碑与验收

* **P0（2–3 天）**

  * 打通 Ideas→蓝图→DAG→运行闭环；Node 可编辑/运行/日志/版本；AI 最小修复闭环（Diff 预览）。
  * **验收**：三节点子图成功；错误→AI 补丁→回滚复现；NDJSON 导出。
* **P1（+2 天）**

  * Run Center（过滤/详情/错误热力/耗时曲线）；Web Components 属性/事件完善；**固定版本运行**。
  * **验收**：按 chainId 回放；外部页面嵌入 `<workflow-flow>` 触发子图运行。
* **P2**

  * 服务化接口、嵌入安全策略（origin 白名单+签名）、AI 性能优化。
  * **验收**：稳定链路发布 API（限流、幂等键）。

---

## 15. 目录地图（Monorepo）

```
apps/
  studio/                 # 主应用（React）
  embeds-demo/            # 嵌入演示
packages/
  @core/domain/           # 领域模型/规则/IR/Schema
  @core/protocol/         # ExecRequest/ExecEvent 协议
  @core/runtime/          # 主线程 Runner 客户端（Comlink 封装）
  @core/observability/    # 日志/追踪/NDJSON
  @data/store/            # Dexie 表与仓储
  @ai/orchestrator/       # 蓝图/拆解/修复最小实现
  @ui/components/         # 纯 UI 组件
  @embeds/wc/             # Web Components（<workflow-node>/<workflow-flow>）
  @workers/executor/      # 执行器 Worker（装载/运行 handler）
  @app/services/          # 应用门面（Commands/Queries + 依赖组装）
configs/
  eslint/ ...             # ESLint 规则（边界守护）
  depcruiser/ ...         # 依赖巡检（可选更严）
docs/
  adr/                    # 架构决策记录
  ir-spec.md
```

---

## 16. 依赖边界守护（工程约束）

* **ESLint**：`import/no-restricted-paths` 禁止 apps 直连 `@data`/`@workers`，禁止 `@core` 反向依赖 apps。
* **Dependency-Cruiser（可选更严）**：CI 中出报表与可视化；对规则破坏直接 fail。
* **TS Path**：仅从各包 `index.ts`（Public API）导入，杜绝深路径。

---

## 17. 最小协议片段（备忘）

```ts
// ExecRequest
{ kind:"EXEC", runId, nodeId, flowId, code, language:"js"|"ts", input, controls:{timeoutMs}, env }
// ExecEvent
"STARTED" | "LOG"({level,fields}) | "RESULT"({output,durationMs}) | "ERROR"({name,message,stack})
```

---

## 18. 决策清单（ADR 摘要）

1. **Runner：Web Worker + 硬超时**（已定）
2. ID：**ULID** 贯穿 runId/chainId/versionId
3. I/O 校验：**Ajv + JSON Schema**
4. 能力模型：**deny-by-default**
5. 日志：结构化 JSON + **NDJSON 导出**
6. 修复：**AST Patch 优先**，降级 Text Diff
7. 版本：线性主干 + 临时分支，支持回滚与固定版本运行
8. 并发：拓扑 + 并行窗口（并发度可配）
9. 嵌入安全：origin 白名单，后续加签名
10. 离线上限：IndexedDB 容量阈值与清理策略
11. 依赖守护：ESLint（必选）+ DepCruiser（可选）
12. 插件：**Manifest + 权限白名单 + Worker 沙箱**（受控加载）

---

## 19. 执行清单（P0 必办）

* [ ] 建 `@core/protocol` / `@workers/executor` / `@core/runtime` 四件套跑通
* [ ] `@app/services` 提供 `startRun()`，写 runs/logs（Dexie）
* [ ] Flow Studio 仅调 App Services（不直连 store/worker）
* [ ] `<workflow-node>` MVP + embeds-demo
* [ ] IR/Schema/ULID 策略落地；NDJSON 导出可用
* [ ] ESLint 边界规则上线（CI）

---

## 20. 前端重构路线（V1）

【起点与基线】

- 交互样板：docs/工作流编排_studio（模拟页面）.jsx（功能齐、依赖多，作交互对齐参考）。
- 可运行壳：src/studio/StudioPage.tsx（依赖少，集成 FlowEditor + RunCenter，作为落地基线）。

【分阶段落地】

- A. 一体化 Console 与全局状态（初版）
  - 统一“运行/错误修复/测试”为 Console Tab；
  - 顶部状态条：当前 runId、用时、成功率、缓存命中、活跃日志源；
  - ⌘K 命令面板与全局搜索（节点/日志/Artifact/参数，先做占位）。
- B. 大图性能与可操作性
  - 采用 FlowCanvas 的虚拟化能力；
  - 接入 utils.autoLayout（elkjs）到画布/工具栏；
  - 状态过滤（failed/running）与框选重跑。
- C. 可观察性与 Trace
  - 链路 id 贯穿（runId/chainId/nodeId）→ 对齐 OTel 语义；
  - Trace 进度条可点击跳转节点；
  - 日志级别过滤、书签、跳至最新/锁定滚动。
- D. 强类型与校验
  - Inspector 表单即时校验（Ajv + JSON Schema）；
  - outputs 变更触发兼容性判定 + DSL 迁移向导（节点级→字段级）。

【闭环验收】

- 从模板创建三节点示例 DAG，Console 中运行；
- 人为制造一次失败 → Inspector 修复 → 重跑成功；
- 保存为“发布版本”并生成差异记录。

【与 TODO 对齐】

- 本节四个阶段分别对应 AGENTS.md 的 P0 条目，执行时以 AGENTS.md 为唯一 TODO 真源。

---

## 21. 范围与约束（前端优先）

- 范围：仅改前端（Studio/Flow/Inspector/Console），不引入新后端；数据仍由 IndexedDB（Dexie）承载。
- 依赖方向：UI → App Services → Domain/Ports → Adapters，禁止反向依赖与深路径导入（仅用各包 index.ts）。
- 沙箱：Web Worker 默认断网，能力 deny-by-default；不触达宿主 Cookie/LocalStorage 以外的敏感域。
- 插件：V1 仅支持 ESM 动态导入 + Worker 沙箱；Module Federation 暂缓。
- 版本：保存即新版本；草稿与“发布版本”分离；可回滚与固定版本运行；多人并发与权限暂不在 V1 范围。
- 观测：结构化日志 + NDJSON 导出；链路 id（runId/chainId/nodeId）贯穿，后续映射 OTel 规范。
- 性能：首屏 < 1.5s；90% 交互 < 100ms；画布渲染 < 16ms/帧；日志写入限流与分片加载。
- 可嵌入：Web Components 握手（origin 白名单），默认不回传明文 I/O，需授权二次取数。

---

## 22. 从模拟页迁移的功能清单（对齐与取舍）

- DSL 迁移向导（节点级→字段级）
  - 现状：docs/工作流编排_studio（模拟页面）.jsx 已有完整流程（自动建议/人工确认/分步回退）。
  - 迁移：抽离成可重用组件，状态托管到全局 store，接入 Inspector 触发器。
- 错误修复 Agent
  - 现状：支持生成补丁 → Dry‑Run → 合并并重跑 → 历史版本保留。
  - 迁移：提示模板收敛（失败节点代码 + 最近 N 行日志 + 输入切片），支持分块补丁选择应用。
- 测试面板（最小）
  - 现状：包含 `extractOutputsFromCode`、`getDownstream`、字段映射建议等用例。
  - 迁移：以 vitest 复写核心单元测试，Studio 内仅保留状态视图与最近结果。
- DSL 预览
  - 现状：图/Inspector/代码三方联动，展示极简 JSON。
  - 迁移：保持只读预览，编辑能力统一走 Inspector 与 Graph。
- 顶部全局状态条
  - 现状：模拟页内已有 Trace 进度条、运行/暂停；
  - 迁移：补足 runId、用时、成功率、缓存命中、活跃日志源汇总。

> 注：模拟页保留为“交互样板”；实际投产以 src/studio/StudioPage.tsx 为入口，逐步吸纳上述能力。

---

### 一句话总结

把“想法→蓝图→DAG→运行/修复/嵌入”作为 **V1 闭环**，用 **Worker 沙箱 + 契约优先 + 受控加载** 保证安全与可扩展，再用 **Run Center** 完成可观测闭环；工程上以 **Public API + 依赖边界守护** 提升可维护性与对 AI 工具的友好度。

---

**引导问题（只问一个）**
为落实“受控包加载 + 插件化”，**V1 基线你更倾向哪条路线？**
**A)** **ESM 动态导入 + Worker 沙箱 + JSON Manifest**（实现快，单体内扩展友好）
**B)** **Module Federation + Worker 沙箱**（跨仓/跨应用生态更强）

选定后，我就把对应的**插件管理器骨架（发现/校验/装载/权限注入）与示例代码**整理成可直接落地的最小实现给你。
